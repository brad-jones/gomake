// Code generated by gomake DO NOT EDIT.

package main

import (
	"fmt"
	"os"
	"runtime/debug"
	"sort"
	"strings"
	"time"

	"github.com/brad-jones/goerr"
	"github.com/fatih/color"
	"github.com/spf13/cobra"
	{{.MakefilePackageImport}}
)

func main() {

	rootCmd := &cobra.Command{}

	// Recover from all panics here to make error handling uniform and maintainable.
	defer goerr.Handle(func(err error) {
		red := color.New(color.FgRed, color.Bold, color.Underline)
		red.Println("gomake has encountered an error!")
		fmt.Println(err)
		fmt.Println()
		if os.Getenv("GOMAKE_DEBUG") == "1" {
			red.Println("debug stack trace")
			if stackTrace, _ := goerr.Trace(err); stackTrace != "" {
				fmt.Println(stackTrace)
			} else {
				debug.PrintStack()
			}
		}
		os.Exit(1)
	})

	rootCmd.Use = "{{.Use}}"
	rootCmd.Short = "{{.Short}}"

	// Inject the version of the built task runner, as a DevOps guy supporting a
	// bunch of other Developers, I find it very useful to be to know exactly
	// which version of the task runner someone is using.
	rootCmd.Version = "{{.Version}}"

	// Make cobra return the version number as entered, this will make it much easier
	// for any other tools to detect the version of gomake should they need to.
	rootCmd.SetVersionTemplate(`{{"{{"}}printf "%s\n" .Version{{"}}"}}`)

	// Optionally give a command a timeout
	rootCmdTimeout := rootCmd.PersistentFlags().StringP("timeout", "t", "",
		"Set this to a value parsable by https://golang.org/pkg/time/#ParseDuration",
	)

	// Commands with arguments get special treatment to the incomming os.Args,
	// this treatmeant happens just before we execute the rootCmd. These slices
	// are populated by each command definition below.
	cmdsWithArgs := []string{}
	cmdsWithOutArgs := []string{}
	cmdsWithArgsOptions := map[string][]string{}
	optionsWithValues := map[string][]string{}
	addCmdWithArgs := func(fullCmdName string, options ...string) {
		if fullCmdName == "" {
			return
		}
		cmdsWithArgs = append(cmdsWithArgs, fullCmdName)
		cmdsWithArgsOptions[fullCmdName] = []string{}
		for _, opt := range options {
			if opt != "" {
				cmdsWithArgsOptions[fullCmdName] = append(
					cmdsWithArgsOptions[fullCmdName],
					opt,
				)
			}
		}
	}
	addOptionsWithValues := func(fullCmdName string, options ...string) {
		if fullCmdName == "" {
			return
		}
		optionsWithValues[fullCmdName] = []string{}
		for _, opt := range options {
			if opt != "" {
				optionsWithValues[fullCmdName] = append(
					optionsWithValues[fullCmdName],
					opt,
				)
			}
		}
	}
	addCmdWithOutArgs := func(fullCmdName string) {
		if fullCmdName == "" {
			return
		}
		cmdsWithOutArgs = append(cmdsWithOutArgs, fullCmdName)
	}

	// NOTE: We do this so we don't get declared and not used errors
	addCmdWithArgs("")
	addCmdWithOutArgs("")
	addOptionsWithValues("")

	{{ define "command" }}
		{{$CobraCmdName := .CobraCmdName}}
		(func() {
			{{$CobraCmdName}}Cmd := &cobra.Command{}
			{{$CobraCmdName}}Cmd.Use = "{{.CmdName}}"
			{{if not (eq .ShortDescription "")}}
				{{$CobraCmdName}}Cmd.Short = "{{.ShortDescription}}"
			{{end}}
			{{if not (eq .LongDescription "")}}
				{{$CobraCmdName}}Cmd.Long = {{$CobraCmdName}}Cmd.Short + "\n{{.LongDescription}}"
			{{end}}
			{{range .Options -}}
				{{.Name}}Opt := {{$CobraCmdName}}Cmd.Flags().{{.FlagType}}("{{.LongName}}", "{{.ShortName}}", {{.DefaultValue}}, "{{.Description}}")
			{{end -}}
			{{if .Args.NoArgs}}
				{{- $CobraCmdName}}Cmd.Args = cobra.NoArgs
				addCmdWithOutArgs("{{.FullCmdName}}")
			{{else}}
				addCmdWithArgs("{{.FullCmdName}}",
					{{range .Options -}}
						"{{.LongName}}", "{{.ShortName}}",
					{{end}}
				)
				addOptionsWithValues("{{.FullCmdName}}",
					{{range .Options -}}
						{{if not (eq .FlagType "BoolP") -}}
							"{{.LongName}}", "{{.ShortName}}",
						{{end -}}
					{{end}}
				)
			{{end}}
			{{if eq .FuncName "gomake_noop"}}
				{{- $CobraCmdName}}Cmd.Run = func(cmd *cobra.Command, args []string) {
					cmd.Help()
				}
			{{else}}
				{{- $CobraCmdName}}Cmd.Run = func(cmd *cobra.Command, args []string) {
					t := {{.FuncName}}(
						{{range .Options -}}
							*{{.Name}}Opt,
						{{end}}
						{{- if not .Args.NoArgs}}args...,{{end}}
					)
					if *rootCmdTimeout != "" {
						timeout, err := time.ParseDuration(*rootCmdTimeout)
						goerr.Check(err)
						t.MustResultWithTimeout(timeout, 1*time.Second)
					} else {
						t.MustResult()
					}
				}
			{{end}}
			{{- range .Commands}}
				{{ template "command" . }}
			{{end}}
			{{.ParentCmdName}}.AddCommand({{$CobraCmdName}}Cmd)
		})()
	{{ end }}

	// -- START: Commands
	{{- range .Commands}}
		{{ template "command" . }}
	{{end}}
	// -- END: Commands

	// This is where we handle commands with variadic / positional arguments.
	// Out of the box cobra will attempt to parse any options / flags, even
	// those provided after positional arguments which makes it impossible to
	// proxy these to other commands. We want a gomake task to be able to do a
	// similar thing to a bash script that does `some-cmd "$@"`
	args := os.Args[1:]
	argsString := strings.Join(args, " ")
	sort.Sort(byLengthDec(cmdsWithArgs))
	OUTER:
	for _, cmdWithArgs := range cmdsWithArgs {
		if !strings.HasPrefix(argsString, cmdWithArgs) {
			continue
		}
		for _, cmdWithOutArgs := range cmdsWithOutArgs {
			if strings.HasPrefix(argsString, cmdWithOutArgs) {
				continue OUTER
			}
		}

		// So at this point we have worked out that we are about to execute a
		// command that accepts positional arguments. Now we will build a slice
		// of options that we know the cobra command will accept. These options
		// do not get bundled into the positional arguments and should be parsed
		// by cobra as expected.
		validOpts := append(cmdsWithArgsOptions[cmdWithArgs],
			"help", "h",
			"timeout", "t",
		)
		opts := []string{}
		argsLength := len(args)
		for i, v := range args {
			opt := strings.TrimLeft(v, "-")
			for _, validOpt := range validOpts {
				if opt == validOpt {
					opts = append(opts, v)
					if argsLength > i+1 {
						for _, optWithValue := range optionsWithValues[cmdWithArgs] {
							if opt == optWithValue {
								opts = append(opts, args[i+1])
								break
							}
						}
					}
				}
			}
		}

		// Now lets build a new set of arguments to pass to the root command.
		// Starting with the command name and the options that we discovered.
		cmdParts := strings.Split(cmdWithArgs, " ")
		start := append(cmdParts, opts...)

		// Then we inject a double dash, this gets cobra to ignore everything after it.
		middle := []string{"--"}

		// And the end of the argument slice is made up of everything else in the orginal args.
		end := args[len(cmdParts)+len(opts):]
		args = append(append(start, middle...), end...)
		break
	}
	rootCmd.SetArgs(args)

	// Execute the generated cobra cli app
	if err := rootCmd.Execute(); err != nil {
		if !strings.HasPrefix(err.Error(), "unknown") {
			goerr.Check(err)
		}
		os.Exit(1)
	}
	os.Exit(0)
}

type byLengthDec []string
func (s byLengthDec) Len() int {
    return len(s)
}
func (s byLengthDec) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}
func (s byLengthDec) Less(i, j int) bool {
    return len(s[i]) > len(s[j])
}
