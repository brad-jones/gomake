// Code generated by gomake DO NOT EDIT.

package main

import (
	"context"
	"fmt"
	"os"
	"runtime/debug"
	"sort"
	"strings"
	"time"

	"github.com/fatih/color"
	"github.com/spf13/cobra"
	errors1 "github.com/pkg/errors"
	errors2 "github.com/go-errors/errors"
	{{.MakefilePackageImport}}
)

type stackTracer interface {
	StackTrace() errors1.StackTrace
}

func main() {

	rootCmd := &cobra.Command{}

	// Recover from all panics here to make error handling uniform and maintainable.
	defer (func() {
		if err := recover(); err != nil {
			red := color.New(color.FgRed, color.Bold, color.Underline)
			red.Println("gomake has encountered an error!")
			fmt.Println(err)
			fmt.Println()
			if os.Getenv("GOMAKE_DEBUG") == "1" {
				red.Println("debug stack trace")
				if errErr, ok := err.(error); ok {
					if v, ok := errors1.Cause(errErr).(stackTracer); ok {
						fmt.Printf("%+v", v.StackTrace())
						os.Exit(1)
					}
				}
				if v, ok := err.(*errors2.Error); ok {
					fmt.Println(v.ErrorStack())
					os.Exit(1)
				}
				debug.PrintStack()
			}
			os.Exit(1)
		}
	})()

	rootCmd.Use = "{{.Use}}"
	rootCmd.Short = "{{.Short}}"

	// Inject the version of the built task runner, as a DevOps guy supporting a
	// bunch of other Developers, I find it very useful to be to know exactly
	// which version of the task runner someone is using.
	rootCmd.Version = "{{.Version}}"

	// Make cobra return the version number as entered, this will make it much easier
	// for any other tools to detect the version of gomake should they need to.
	rootCmd.SetVersionTemplate(`{{"{{"}}printf "%s\n" .Version{{"}}"}}`)

	// Optionally give a command a timeout
	rootCmdTimeout := rootCmd.PersistentFlags().StringP("timeout", "t", "",
		"Set this to a value parsable by https://golang.org/pkg/time/#ParseDuration",
	)

	// Use locally scoped functions as to not conflict with actual gomake functions
	getContext := func() (context.Context, func()) {
		ctx := context.Background()
		ctxCancel := func() {}
		if *rootCmdTimeout != "" {
			timeout, err := time.ParseDuration(*rootCmdTimeout)
			if err != nil {
				panic(err)
			}
			ctx, ctxCancel = context.WithTimeout(ctx, timeout)
		}
		return ctx, ctxCancel
	}

	// Commands with arguments get special treatment to the incomming os.Args,
	// this treatmeant happens just before we execute the rootCmd. But this
	// slice is populated by each command definition below.
	cmdsWithArgs := []string{}
	cmdsWithOutArgs := []string{}
	cmdsWithArgsOptions := map[string][]string{}
	optionsWithValues := map[string][]string{}
	addCmdWithArgs := func(fullCmdName string, options ...string) {
		if fullCmdName == "" {
			return
		}
		cmdsWithArgs = append(cmdsWithArgs, fullCmdName)
		cmdsWithArgsOptions[fullCmdName] = []string{}
		for _, opt := range options {
			if opt != "" {
				cmdsWithArgsOptions[fullCmdName] = append(
					cmdsWithArgsOptions[fullCmdName],
					opt,
				)
			}
		}
	}
	addOptionsWithValues := func(fullCmdName string, options ...string) {
		if fullCmdName == "" {
			return
		}
		optionsWithValues[fullCmdName] = []string{}
		for _, opt := range options {
			if opt != "" {
				optionsWithValues[fullCmdName] = append(
					optionsWithValues[fullCmdName],
					opt,
				)
			}
		}
	}
	addCmdWithOutArgs := func(fullCmdName string) {
		if fullCmdName == "" {
			return
		}
		cmdsWithOutArgs = append(cmdsWithOutArgs, fullCmdName)
	}

	// NOTE: We do this so we don't get declared and not used errors
	addCmdWithArgs("")
	addCmdWithOutArgs("")
	addOptionsWithValues("")

	{{ define "command" }}
		{{$CobraCmdName := .CobraCmdName}}
		(func() {
			{{$CobraCmdName}}Cmd := &cobra.Command{}
			{{$CobraCmdName}}Cmd.Use = "{{.CmdName}}"
			{{if not (eq .ShortDescription "")}}
				{{$CobraCmdName}}Cmd.Short = "{{.ShortDescription}}"
			{{end}}
			{{if not (eq .LongDescription "")}}
				{{$CobraCmdName}}Cmd.Long = {{$CobraCmdName}}Cmd.Short + "\n{{.LongDescription}}"
			{{end}}
			{{range .Options -}}
				{{.Name}}Opt := {{$CobraCmdName}}Cmd.Flags().{{.FlagType}}("{{.LongName}}", "{{.ShortName}}", {{.DefaultValue}}, "{{.Description}}")
			{{end -}}
			{{if .Args.NoArgs}}
				{{- $CobraCmdName}}Cmd.Args = cobra.NoArgs
				addCmdWithOutArgs("{{.FullCmdName}}")
			{{else}}
				addCmdWithArgs("{{.FullCmdName}}",
					{{range .Options -}}
						"{{.LongName}}", "{{.ShortName}}",
					{{end}}
				)
				addOptionsWithValues("{{.FullCmdName}}",
					{{range .Options -}}
						{{if not (eq .FlagType "BoolP") -}}
							"{{.LongName}}", "{{.ShortName}}",
						{{end -}}
					{{end}}
				)
			{{end}}
			{{if eq .FuncName "gomake_noop"}}
				{{- $CobraCmdName}}Cmd.Run = func(cmd *cobra.Command, args []string) {
					cmd.Help()
				}
			{{else}}
				{{- $CobraCmdName}}Cmd.Run = func(cmd *cobra.Command, args []string) {
					ctx, cancel := getContext()
					defer cancel()
					var err interface{}
					d := make(chan interface{})
					go func() {
						{{if .HasErr}}err := {{end}}{{.FuncName}}(
							{{if .HasCtx}}ctx,{{end}}
							{{range .Options -}}
								*{{.Name}}Opt,
							{{end}}
							{{- if not .Args.NoArgs}}args...,{{end}}
						)
						d <- {{if .HasErr}}err{{else}}nil{{end}}
					}()
					select {
					case <-ctx.Done():
						panic(ctx.Err())
					case err = <-d:
						panic(err)
					}
				}
			{{end}}
			{{- range .Commands}}
				{{ template "command" . }}
			{{end}}
			{{.ParentCmdName}}.AddCommand({{$CobraCmdName}}Cmd)
		})()
	{{ end }}

	// -- START: Commands
	{{- range .Commands}}
		{{ template "command" . }}
	{{end}}
	// -- END: Commands

	// This is where we handle commands with variadic / positional arguments.
	// Out of the box cobra will attempt to parse any options / flags, even
	// those provided after positional arguments which makes it impossible to
	// proxy these to other commands. We want a gomake task to be able to do a
	// similar thing to a bash script that does `some-cmd "$@"`
	args := os.Args[1:]
	argsString := strings.Join(args, " ")
	sort.Sort(byLengthDec(cmdsWithArgs))
	OUTER:
	for _, cmdWithArgs := range cmdsWithArgs {
		if !strings.HasPrefix(argsString, cmdWithArgs) {
			continue
		}
		for _, cmdWithOutArgs := range cmdsWithOutArgs {
			if strings.HasPrefix(argsString, cmdWithOutArgs) {
				continue OUTER
			}
		}

		// So at this point we have worked out that we are about to execute a
		// command that accepts positional arguments. Now we will build a slice
		// of options that we know the cobra command will accept. These options
		// do not get bundled into the positional arguments and should be parsed
		// by cobra as expected.
		validOpts := append(cmdsWithArgsOptions[cmdWithArgs],
			"help", "h",
			"timeout", "t",
		)
		opts := []string{}
		argsLength := len(args)
		for i, v := range args {
			opt := strings.TrimLeft(v, "-")
			for _, validOpt := range validOpts {
				if opt == validOpt {
					opts = append(opts, v)
					if argsLength > i+1 {
						for _, optWithValue := range optionsWithValues[cmdWithArgs] {
							if opt == optWithValue {
								opts = append(opts, args[i+1])
								break
							}
						}
					}
				}
			}
		}

		// Now lets build a new set of arguments to pass to the root command.
		// Starting with the command name and the options that we discovered.
		cmdParts := strings.Split(cmdWithArgs, " ")
		start := append(cmdParts, opts...)

		// Then we inject a double dash, this gets cobra to ignore everything after it.
		middle := []string{"--"}

		// And the end of the argument slice is made up of everything else in the orginal args.
		end := args[len(cmdParts)+len(opts):]
		args = append(append(start, middle...), end...)
		break
	}
	rootCmd.SetArgs(args)

	// Execute the generated cobra cli app
	if err := rootCmd.Execute(); err != nil {
		if !strings.HasPrefix(err.Error(), "unknown") {
			panic(err)
		}
		os.Exit(1)
	}
	os.Exit(0)
}

type byLengthDec []string
func (s byLengthDec) Len() int {
    return len(s)
}
func (s byLengthDec) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}
func (s byLengthDec) Less(i, j int) bool {
    return len(s[i]) > len(s[j])
}
