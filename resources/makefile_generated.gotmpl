// Code generated by gomake DO NOT EDIT.
// cache-hash: {{.CacheHash}}

package main

import (
	"context"
	"fmt"
	"os"
	"runtime/debug"
	"time"

	"github.com/spf13/cobra"
	"github.com/fatih/color"
)

func main() {

	rootCmd := &cobra.Command{}

	// Recover from all panics here to make error handling uniform and maintainable.
	defer (func() {
		if err := recover(); err != nil {
			red := color.New(color.FgRed, color.Bold, color.Underline)
			red.Println("gomake has encountered an error!")
			fmt.Println(err)
			fmt.Println()
			if os.Getenv("GOMAKE_DEBUG") == "1" {
				red.Println("debug stack trace")
				debug.PrintStack()
				fmt.Println()
			}
			os.Exit(1)
		}
	})()

	// TODO: Allow usage and top level description to be overwitten
	rootCmd.Use = "gomake"
	rootCmd.Short = "Makefile written in golang"

	// Inject the version of the built task runner, as a DevOps guy supporting a
	// bunch of other Developers, I find it very useful to be to know exactly
	// which version of the task runner someone is using.
	rootCmd.Version = "{{.Version}}"

	// Make cobra return the version number as entered, this will make it much easier
	// for any other tools to detect the version of gomake should they need to.
	rootCmd.SetVersionTemplate(`{{"{{"}}printf "%s\n" .Version{{"}}"}}`)

	// Optionally give a command a timeout
	rootCmdTimeout := rootCmd.PersistentFlags().StringP("timeout", "t", "",
		"Set this to a value parsable by https://golang.org/pkg/time/#ParseDuration",
	)

	// Use locally scoped functions as to not conflict with actual gomake functions
	getContext := func() (context.Context, func()) {
		ctx := context.Background()
		ctxCancel := func() {}
		if *rootCmdTimeout != "" {
			timeout, err := time.ParseDuration(*rootCmdTimeout)
			if err != nil {
				panic(err)
			}
			ctx, ctxCancel = context.WithTimeout(ctx, timeout)
		}
		return ctx, ctxCancel
	}

	{{ define "command" }}
		{{$CobraCmdName := .CobraCmdName}}
		(func() {
			{{$CobraCmdName}}Cmd := &cobra.Command{}
			{{$CobraCmdName}}Cmd.Use = "{{.CmdName}}"
			{{$CobraCmdName}}Cmd.Short = "{{.ShortDescription}}"
			{{$CobraCmdName}}Cmd.Long = {{$CobraCmdName}}Cmd.Short + "\n{{.LongDescription}}"
			{{range .Options -}}
				{{.Name}}Opt := {{$CobraCmdName}}Cmd.Flags().{{.FlagType}}("{{.Name}}", "{{.ShortName}}", {{.DefaultValue}}, "{{.Description}}")
			{{end -}}
			{{if .Args.NoArgs}}
				{{- $CobraCmdName}}Cmd.Args = cobra.NoArgs
			{{end}}
			{{- $CobraCmdName}}Cmd.Run = func(cmd *cobra.Command, args []string) {
				ctx, cancel := getContext()
				defer cancel()
				var err interface{}
				d := make(chan interface{})
				go func() {
					defer func() {
						err := recover()
						d <- err
					}()
					{{if .HasErr}}err := {{end}}{{.FuncName}}(
						{{if .HasCtx}}ctx,{{end}}
						{{range .Options -}}
							*{{.Name}}Opt,
						{{end}}
						{{- if not .Args.NoArgs}}args...,{{end}}
					)
					d <- {{if .HasErr}}err{{else}}nil{{end}}
				}()
				select {
				case <-ctx.Done():
					panic(ctx.Err())
				case err = <-d:
					panic(err)
				}
			}
			{{- range .Commands}}
				{{ template "command" . }}
			{{end}}
			{{.ParentCmdName}}.AddCommand({{$CobraCmdName}}Cmd)
		})()
	{{ end }}

	// -- START: Commands
	{{- range .Commands}}
		{{ template "command" . }}
	{{end}}
	// -- END: Commands

	// Execute the generated cobra cli app
	rootCmd.Execute()
	os.Exit(0)
}
